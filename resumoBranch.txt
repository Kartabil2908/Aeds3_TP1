
# üéÅ Resumo do Projeto: PresenteF√°cil 1.0

### ‚ú® Funcionalidades Principais

* **Gest√£o Completa de Utilizadores:** Permite criar, ler, atualizar e apagar utilizadores.
* **Autentica√ß√£o:** Possui um sistema de login que verifica e-mail e palavra-passe.
* **Dois Tipos de Exclus√£o:**
    1.  **Desativar Conta (Soft Delete):** Marca o utilizador como "inativo" mas mant√©m os dados guardados. O utilizador desativado n√£o pode fazer login.
    2.  **Excluir Conta (Hard Delete):** Apaga permanentemente os dados do utilizador do ficheiro, libertando o espa√ßo para ser reutilizado.

### üõ†Ô∏è Arquitetura T√©cnica

O sistema utiliza uma abordagem de baixo n√≠vel para a persist√™ncia de dados:

* **Ficheiros Bin√°rios:** Todos os dados s√£o guardados em ficheiros `.db` na pasta `data/usuarios`. O ficheiro principal que cont√©m os dados completos dos utilizadores √© o `usuarios.db`.

* **Indexa√ß√£o com Hash Extens√≠vel:** Para encontrar os dados rapidamente sem ter de ler o ficheiro inteiro, o sistema usa uma t√©cnica avan√ßada de indexa√ß√£o. Existem dois √≠ndices:
    * **√çndice Prim√°rio:** Utilizado para encontrar um utilizador instantaneamente pelo seu `ID`.
    * **√çndice Secund√°rio:** Utilizado para encontrar um utilizador rapidamente pelo seu `e-mail`, essencial para a funcionalidade de login.




---------------------------------------------------------------------------------------------------------------------------------------------


---

# üéÅ An√°lise Detalhada do Projeto: PresenteF√°cil 1.0


## 1. Fluxo de uma Opera√ß√£o: A Jornada de um Login

Para entender a complexidade e a eleg√¢ncia do sistema, vamos rastrear o que acontece quando um utilizador tenta fazer login:

1.  **Interface (UI Layer):** O utilizador interage com o `Terminal` e insere o seu e-mail e palavra-passe. O `Terminal` captura esta informa√ß√£o e invoca o `ControladorUsuario`.
2.  **L√≥gica de Neg√≥cio (Business Logic Layer):** O `ControladorUsuario` recebe os dados e a sua primeira tarefa √© **encontrar o utilizador**. Em vez de ler o ficheiro `usuarios.db` inteiro (o que seria extremamente ineficiente), ele delega esta tarefa √† camada de acesso a dados, chamando `arqUsuarios.read(email)`.
3.  **Acesso a Dados (Data Access Layer):**
    a.  A classe `ArquivoUsuario` recebe o e-mail. A sua primeira a√ß√£o √© consultar o **√çndice Secund√°rio por E-mail**.
    b.  Ela calcula o `hash` do e-mail e usa a estrutura de **Hash Extens√≠vel** (`indiceIndiretoEmail`) para procurar nos ficheiros `indiceEmail.d.db` e `indiceEmail.c.db`.
    c.  Se for bem-sucedido, o √≠ndice retorna o `ID` do utilizador correspondente √†quele e-mail.
    d.  Agora, com o `ID` em m√£os, a classe `ArquivoUsuario` invoca `super.read(id)`, chamando o m√©todo da sua classe pai, `Arquivo`.
    e.  A classe `Arquivo` consulta o **√çndice Prim√°rio por ID**.
    f.  Ela usa o `ID` (que funciona como um hash direto neste caso) na sua pr√≥pria estrutura de **Hash Extens√≠vel** (`indiceDireto`) para procurar nos ficheiros `usuarios.d.db` e `usuarios.c.db`.
    g.  O √≠ndice prim√°rio retorna o `endere√ßo`, que √© a posi√ß√£o exata em bytes onde o registo do utilizador come√ßa no ficheiro principal `usuarios.db`.
    h.  Finalmente, a classe `Arquivo` usa `arquivo.seek(endereco)` para saltar diretamente para essa posi√ß√£o, l√™ os bytes do registo e os desserializa, reconstruindo o objeto `Usuario`.
4.  **Conclus√£o da L√≥gica:** O objeto `Usuario` √© retornado ao `ControladorUsuario`. Agora, com os dados do utilizador em mem√≥ria, o controlador compara o hash da palavra-passe digitada com o hash armazenado e verifica se o campo `ativo` √© `true`.
5.  **Feedback ao Utilizador:** O `ControladorUsuario` retorna o resultado ao `Terminal`, que exibe a mensagem de sucesso ou falha no login.

Este fluxo demonstra uma arquitetura de m√∫ltiplas camadas com uma clara separa√ß√£o de responsabilidades, onde cada classe faz uma tarefa espec√≠fica e bem definida.

---

## 2. An√°lise Profunda da Camada de Persist√™ncia

Esta √© a parte mais complexa e fundamental do projeto.

### 2.1. O Ficheiro de Dados Principal (`usuarios.db`)

Este n√£o √© um simples ficheiro de texto. √â um ficheiro bin√°rio estruturado para emular uma tabela de base de dados.

- **Cabe√ßalho do Ficheiro (Primeiros 12 bytes):**
  - `√∫ltimo ID (int - 4 bytes)`: Um contador que garante que cada novo utilizador tenha um ID √∫nico e auto-incremental.
  - `ponteiro da lista de livres (long - 8 bytes)`: A cabe√ßa de uma lista encadeada que aponta para o primeiro espa√ßo livre deixado por um registo exclu√≠do.

- **Estrutura de cada Registo:**
  - `L√°pide (byte - 1 byte)`: Indica o estado do registo.
    - `' '` (espa√ßo): Registo ativo. Os dados s√£o v√°lidos.
    - `'*'` (asterisco): Registo "morto" (exclu√≠do permanentemente). Este espa√ßo est√° na lista de livres e pode ser sobrescrito por um novo registo.
  - `Tamanho do Registo (short - 2 bytes)`: Informa quantos bytes os dados do utilizador ocupam. Essencial para saber onde o pr√≥ximo registo come√ßa.
  - `Dados (array de bytes)`: O objeto `Usuario` serializado, convertido para bytes atrav√©s do m√©todo `.toByteArray()`.

- **Gest√£o de Espa√ßo (Exclus√£o e Inser√ß√£o):**
  - Ao **excluir** um utilizador (`delete`), o sistema n√£o apaga os bytes. Ele simplesmente muda a l√°pide para `'*'` e, atrav√©s de uma l√≥gica complexa em `addDeleted`, insere este "buraco" numa lista encadeada de espa√ßos livres, ordenada por tamanho. O ponteiro para o pr√≥ximo espa√ßo livre √© escrito no pr√≥prio espa√ßo do registo morto.
  - Ao **criar** um novo utilizador (`create`), o sistema primeiro verifica na lista de livres (`getDeleted`) se existe algum "buraco" de um registo antigo que seja grande o suficiente para albergar os novos dados. Se houver, ele reutiliza esse espa√ßo. Caso contr√°rio, ele escreve o novo registo no final do ficheiro. Esta estrat√©gia combate a fragmenta√ß√£o do ficheiro.

### 2.2. A Magia da Indexa√ß√£o: Hash Extens√≠vel

Ler o `usuarios.db` sequencialmente para encontrar um utilizador seria invi√°vel. √â aqui que entram os √≠ndices. O **Hash Extens√≠vel** √© uma estrutura de dados brilhante para este fim, pois √© armazenada em ficheiro e cresce (e encolhe) de forma eficiente.

- **Componentes:**
  - **Diret√≥rio (ficheiros `.d.db`):** √â um array de ponteiros (`long`). O tamanho deste array √© sempre uma pot√™ncia de 2, determinada pela `profundidade global (pG)`. Se `pG=4`, o diret√≥rio tem `2^4 = 16` entradas. Cada entrada aponta para um cesto.
  - **Cestos ou Buckets (ficheiros `.c.db`):** S√£o blocos de tamanho fixo que armazenam os dados do √≠ndice (ex: `ParEmailID` ou `ParIDEndereco`). Cada cesto tem uma `profundidade local (pL)` que indica quantos bits do hash s√£o usados para identificar aquele cesto.

- **Funcionamento (Create/Insert):**
  1.  Calcula-se o hash da chave (e-mail ou ID).
  2.  Usa-se os `pG` primeiros bits do hash para encontrar uma entrada no diret√≥rio. `posi√ß√£o = hash % 2^pG`.
  3.  Segue-se o ponteiro dessa entrada para encontrar o endere√ßo do cesto correto no ficheiro `.c.db`.
  4.  L√™-se o cesto para a mem√≥ria, insere-se o novo par (ex: `<yas@gmail.com, 22>`) e reescreve-se o cesto no ficheiro.

- **O Ponto Cr√≠tico: Cesto Cheio**
  - Se o cesto onde se tenta inserir j√° est√° cheio, a "magia" acontece:
    1.  **Divis√£o do Cesto:** Cria-se um cesto novo. Os elementos do cesto antigo (mais o novo elemento) s√£o redistribu√≠dos entre o cesto antigo e o novo, com base no pr√≥ximo bit do seu hash.
    2.  **Atualiza√ß√£o do Diret√≥rio:** Os ponteiros no diret√≥rio s√£o atualizados para apontar para estes dois cestos.
    3.  **Duplica√ß√£o do Diret√≥rio:** Se a `profundidade local (pL)` do cesto que se dividiu for igual √† `profundidade global (pG)` do diret√≥rio, significa que o diret√≥rio n√£o tem "bits" suficientes para diferenciar os dois novos cestos. Neste caso, o diret√≥rio inteiro √© duplicado de tamanho (`pG` √© incrementado) e os ponteiros s√£o ajustados. Este processo permite que a estrutura de dados cres√ßa de forma controlada e sob demanda.

- **Tipos de √çndice Implementados:**
  - **√çndice Prim√°rio (`indiceDireto`):** Usa `ParIDEndereco`. Mapeia `ID -> Endere√ßo`. √â a forma mais r√°pida de encontrar um registo.
  - **√çndice Secund√°rio (`indiceIndiretoEmail`):** Usa `ParEmailID`. Mapeia `hash(E-mail) -> ID`. √â um passo intermedi√°rio essencial para permitir pesquisas por campos que n√£o sejam a chave prim√°ria.

---

## 3. Conclus√£o Final

Este projeto vai muito al√©m de um simples CRUD. √â uma simula√ß√£o completa de um motor de base de dados de baixo n√≠vel, implementando conceitos avan√ßados como:

-   **Acesso Aleat√≥rio a Ficheiros** para performance.
-   **Serializa√ß√£o de Objetos** para armazenamento bin√°rio.
-   **Gest√£o de Espa√ßo em Disco** com listas de reaproveitamento para evitar fragmenta√ß√£o.
-   **Indexa√ß√£o Prim√°ria e Secund√°ria** para otimiza√ß√£o de consultas.
-   **Estruturas de Dados Din√¢micas e Persistentes** como o Hash Extens√≠vel.
-   **Arquitetura Multi-camada** com clara separa√ß√£o de responsabilidades (UI, L√≥gica, Dados).
